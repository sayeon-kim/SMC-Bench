	.data                  # Data declaration section
vec1:   .word 22, 0, 25
vec2:   .word 7, 429, 6
result: .word 0
        
    	.text                  # Code section
main:   li $4, 3           # 벡터크기는 3
        li $8, 0           # 카운터 ?
        la $9, gen         # 9번레지스터에 gen 라벨의 주소를 저장 
        la $11, tpl        # 11번레지스터에 tpl 라벨의 주소를 저장
        lw $12, 0($11)	   # tpl라벨의 첫번째 명령어를 gen 첫번째 명령어에 덮어씌움.
        sw $12, 0($9)      # tpl라벨의 첫번째 명령어를 gen 첫번째 명령어에 덮어씌움.
        addi $9, $9, 4     # 9번 레지스터 = gen 두번째 명령어 

loop:   beq $8, $4, post   # 8번 레지스터는 카운터, 4번 레지스터는 벡터의 크기 두개가 같으면 post로 이동
        li $13, 4	   # 13번 레지스터에 4를 저장
        mul $13, $13, $8   # 13번 레지스터에 카운터와 4를 곱한값을 저장 $13은 그럼 0, 4 ,8 이런식으로 loop가 돌때마다 값이 할당됨.
        lw $10, vec1($13)  # 10번 레지스터에 벡터의 원소를 가져옴. 백터 또한 4바이트씩 떨어져있으므로 13번레지스터에 4를 곱해서 인덱스를 구한것 같다.
        beqz $10, next     # 10번 레지스터가 0이면 스킵
        lw $12, 4($11)	   # 12번 레지스터에 tpl + 4 명령어 (2번째 명령어 저장) lw $13, 0($4)  12번레지스터 0x8c8d0000 
        add $12, $12, $13  # 12번 레지스터에 13번 레지스터를 더한값을 저장	
        sw $12, 0($9)	   # 12번 레지스터에 add $2 $2 $12명령어를 9번 레지스터에 저장 
        lw $12, 8($11)     # 12번 레지스터에 tpl 3번째 명령어 저장 li $12, 0
        add $12, $12, $10  # 12번 레지스터에 벡터의 원소를 더함. 10번레지스터에는 벡터의 원소값이 들어가있다. 12번레지스터는 0x240c0000 -> 0x240c0016 됨,
        sw $12, 4($9)	   # gen 첫번째 명령어를 li $12, $10으로 바꿈.
        lw $12, 12($11)	   # 12번째 레지스터에  mul $12, $12, $13 저장
        sw $12, 8($9) 	   # gen 3번째 명령어를 mul $12, $12, $13로 저장
        lw $12, 16($11)	   # 12번레지스터에 add $2, $2, $12로 저장
        sw $12, 12($9)	   # gen 4번째 명령어를 add $2 $2 $12로 저장
        addi $9, $9, 16    # 9번 레지스터가 add $2, $2, $12    # res += 25 * v[2]

next:   addi $8, $8, 1
        j loop

post:   lw $12, 20($11)
        sw $12, 0($9)
        la $4, vec2
        jal gen

        sw $2, result
        j main

tpl:    li $2, 0           # template code
        lw $13, 0($4)
        li $12, 0
        mul $12, $12, $13
        add $2, $2, $12
        jr $31	

#Generated code of vector dot product
gen:	li $2, 0           # int gen(int *v)
	lw $13, 0($4)      # {
	li $12, 22         # int res = 0;
	mul $12, $12, $13  # res += 22 * v[0];
	add $2, $2, $12    # res += 25 * v[2];
	lw $13, 8($4)      # return res;
	li $12, 25         # }
	mul $12, $12, $13
	add $2, $2, $12
	jr $31